Pre knowledge.

1.HTML 5
2.CSS 3
3.Javascript - ES 5 and ES 6
4.node js fundamentals - npm
....................................................................................
				Vue.js
...................................................................................

What is Vue.js?
 Vue.js is a javascript framework for building user interfaces.

User interface could be browser,mobile apps,other device based apps.

Vue is more popular for building browser based web applications.


What are different types of Web Applications?

Web History
https://home.web.cern.ch/science/computing/birth-web

Server side web apps
1.static web apps - 1989 to 1995
   -HTML
2.Dynamic content generation web app -1996 to till date
   -CGI - C/Perl
   -J2EE - Java,JavaServlets
   -ASP  - Vbscript,VB
   -PHP  - Php
output : HTML
 etc.....
3.Web Services - ECOMMERCE(B2 to B2) - 1998 To till date
  DATA is exchanged between two systems 
  Common data formats
   -XML - SOAP web services
  -Multi format(JSON)- RESTFull Web Services / GraphQL    

Client side web apps

Netscap communication introduced a web browser called "Navigator".

Navigator started failing down once microsoft announced free browser in 1995 as part of win 95 os.

Natscap started entering in to server side market,but again failed.

1995 netscap team started thinking about new technology- how to process "html pages" in the client side after rendering - Client side web apps.


Client Side Web Architecture:

Browser-HTML

............................................................................................
				Internals of HTML Representation
..........................................................................................

HTML is programming language -  DSL pl /declarative pl.


index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |
Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
.....................................................................................
				Runtime  -  Allocate Memory for HTML
...........................................................................................				
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c

body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree (c)

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
 |
 |
Layout/Paint Engine: will convert nodes into pxs : final output
...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be represented as Objects" : Object oriented Document Programming.

..............................................................................................
				Birth of Frameworks and libs



............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.

.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
How to build client side web app?

1.Enchancing html(genereated by server) by adding javascript /js lib(jquery)
2.Web component model.
 https://developer.mozilla.org/en-US/docs/Web/Web_Components
3.SPA - Single Page Web Arch
4.Full Stack/SSR(Server side rendering)
5.JamStack/SSG(Static Site Generation)
6.Mobile,desktop,WebGL


Based on ,use case we can pickup any one of the methods to build client side web apps, but most popular one is SPA,SSR

Vue js can be used to build any type of client side web apps(spa,ssr,ssg)

implementation

1.Standalone Script

Vue can be used as a standalone script file - no build step required! If you have a backend framework already rendering most of the HTML, or your frontend logic isn't complex enough to justify a build step, this is the easiest way to integrate Vue into your stack. You can think of Vue as a more declarative replacement of jQuery in such cases


=>It is old model of writing code.
=>server always creates html pages , sends html to browser
=>Client side we need to submit forms
   we need to validate the forms-js can be used.
   some animations 
   if you want to submit forms to the server for processing some data
   (ajax)

Technologies:
  jQuery
  Vue.js

2.Single-Page Application (SPA):
Some applications require rich interactivity and non-trivial stateful logic on the frontend. The best way to build such applications is to use an architecture where Vue not only controls the entire page, but also handles data updates and navigation without having to reload the page. This type of application is typically referred to as a Single-Page Application (SPA).

SPAs typically require the backend to expose API endpoints - but you can also pair Vue with solutions like Inertia.js to get the SPA benefits while retaining a server-centric development model.

Fullstack / SSR

Pure client-side SPAs are problematic when the app is sensitive to SEO and time-to-content. This is because the browser will receive a largely empty HTML page, and has to wait until the JavaScript is loaded before rendering anything.

Vue provides first-class APIs to "render" a Vue app into HTML strings on the server. This allows the server to send back already-rendered HTML, allowing end users to see the content immediately while the JavaScript is being downloaded. Vue will then "hydrate" the application on the client side to make it interactive. This is called Server-Side Rendering (SSR) and it greatly improves Core Web Vital metrics such as Largest Contentful Paint (LCP).

There are higher-level Vue-based frameworks built on top of this paradigm, such as Nuxt, which allow you to develop a fullstack application using Vue and JavaScript.


JAMStack / SSG#
Server-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files. This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.

The Vue team maintains a static-site generator called VitePress, which powers this website you are reading right now! In addition, Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.


Beyond the Web:
...............

Although Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:

Build desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the terminal!



App selections:

Whether your app is legacy server side apps built using j2ee or .net,php,rails--->
 Standalone vue.js

Your app is api centeric(webservices)/microservices

Vue can be used as "SPA"

SPA With SSR for better optimization and SEO ready

SPA and SSR With SSG/JAM Stack - where your app is having static data


Getting started with Vue:
........................

Project Setup:
..............

1.without build tools

2.with build tools


1.without build tools

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.


Prod Build
 <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>


....................................................................................
				Vue Application
....................................................................................

Vue is just javascript framework, offers apis,infrastructure to build "DOM" programming.

DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)

...................................................................................
How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Smaller UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

Steps:

1.create Application Object

Pro Vue 3.
var app = new Vue({   })
    
Vue 3:

1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

....................................................................................
			A.Via Global Vue variable
...................................................................................

Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

etc..

1.2. call method called createApp

Creates an application instance.

function createApp(rootComponent: Component, rootProps?: object): App

const app = createApp()

console.log(app)

Application Object methods:
............................

component: ƒ component(name, component)
config: (...)
directive: ƒ directive(name, directive)
mixin: ƒ mixin(mixin)
mount: (containerOrSelector) => {…}
provide: ƒ provide(key, value)
unmount: ƒ unmount()
use: ƒ use(plugin, ...options)
version: "3.2.36"
_component: {}
_container: null
_context: {app: {…}, config: {…}, mixins: Array(0), components: {…}, directives: {…}, …}
_instance: null
_props: null
_uid: 0


       //way -1
        //     //get Vue Instance
        //  const vue  = Vue
        // // console.log(vue)
        // const app = vue.createApp()
        // console.log(app)
        //way -2
        // const app = Vue.createApp()
        // console.log(app)
        //way - 3 : es 6 destructuring syntax
        const { createApp } = Vue
        const app = createApp()
        console.log(app)

.....................................................................................
				B.Via ES 6 modules
....................................................................................

Scripts should imported using "importmap" of script tag

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E6 Modules-without Build tools</title>
    <!-- Poly file for import maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
</head>

<body>
    <div id="app">

    </div>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
    <script type="module">
        import { createApp } from 'vue'
        const app = createApp()
        console.log(app)
    </script>

</body>

</html>


Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>

Not for production

The import-maps-based setup is meant for learning only - if you intend to use Vue without build tools in production, make sure to check out the Production Deployment Guide.
..................................................................................
			    Root Component(Root Element)
...................................................................................

  In tree structure, root element must be necessary, in vue every element is created by component, so we need  root Component.

In React:
 function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }
In Vue:
 Component is object which is represented as literal object.

const Logo ={

}

What component contains:
 component information can be categorized into various segments

1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends
Misc

name
inheritAttrs
components
directives

Component Instance api

$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()
.....................................................................................
				Vue Coding Style
....................................................................................
				
Vue coding can be classified into two category

Options api based style - old vue(Vue 2.x)

Composition api based style - new Vue(Vue 3.x)
				
..............................................................................

Template:
 => It is html along with some special instructions
 => It is compiled into sequence of java script methods by vue compilers
 => Every component will have template
 => root component uses container element as template

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Root Component</title>
  <!-- Poly file for import maps -->
  <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
  <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
</head>

<body>
  <div id="app">

  </div>

  <script type="module">
    import { createApp } from 'vue'

    const rootComponent = {
      template: `
             <h1>Welcome to Vue App</h1>
             <p>How are you?</p>
      `
    }
    const app = createApp(rootComponent)

    //rendering root Component on existing dom tree
    app.mount('#app')
  </script>

</body>

</html>

...................................................................................
			  How to write modular code

1.you have to write application component in a separate folders and files

src
 |
 components
    |
    App.js
index.html

src/App.js
export default {
    template: `
        <div>
             <h1>Vue App</h1>
        </div>
    `
}
index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root Component</title>
    <!-- Poly file for import maps -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
</head>

<body>
    <div id="app">

    </div>

    <script type="module">
        import { createApp } from 'vue'
        import App from './src/App.js'
        createApp(App).mount('#app')
    </script>

</body>

</html>
			.....................................................................................
			How to setup vue Apps using Build Tools
.....................................................................................

Build tools:
 Which are javascript based tools for create,manage java script apps
 Build tools are based on npm tool.

Build tools:
 Webpack
 rollup

.....................................................................................
			How to setup vue Apps using Build Tools
.....................................................................................

Tool for creating and Managining vue app life cycles


vue-cli
 old pattern
vite
 modern pattern - recommended
 npm init vue@latest

This is abstraction for vite based project templates

>npm init vue@latest
Need to install the following packages:
  create-vue@latest
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-modern
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add Cypress for both Unit and End-to-End testing? ... No / Yes
√ Add ESLint for code quality? ... No / Yes
√ Add Prettier for code formatting? ... No / Yes

Scaffolding project in E:\session\Toshiba\vue-session\vue-modern...

Done. Now run:

  cd vue-modern
  npm install
  npm run lint
  npm run dev
....................................................................................
				Component Creational Pattern
....................................................................................

1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

2.Single File Components -SFC

 It is more declarative way of creating components
 As name suggest, All Component logic inside single file.

Component has three major sections

1.template
2.javascript
3.style

In SFC Pattern, we isloate very clearly into three sections

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>


Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

SFC components are saved with fileName.vue
....................................................................................
                                SFC API styles
...................................................................................

				SFC Component
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api



Commonality between both patterns

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>


Options Api Style Pattern:
<!-- Options Api Pattern -->
<script>
//you have to return options object
export default {

}
</script>
<template>
  <h1>Welcome to Vue App-Using SFC On Options Object Pattern</h1>
</template>
<style>
</style>
.....................................................................................
Compostion Api Pattern:

<!-- Compostion api Pattern :Using setup function  -->
<script>
 //java script code can go directly

export default {
  setup(){

  }
}
 
</script>
<template>
  <h1>Single File Component using Composition Api Pattern</h1>
</template>
<style>
</style>
<!-- Compostion api Pattern  -->
<script setup>
 //java script code can go directly
 
</script>
<template>
  <h1>Single File Component using Composition Api Pattern</h1>
</template>
<style>
</style>
....................................................................................
			Component tree-Component Creational Pattern
....................................................................................

HTML View:

<body>
 <div id="root">
    <div>
	<h1>Welcome to Vue</h1>
    </div>
 </div>
</body>


Vue View
<body>
 <div id="root">
    <App>
	<Greeter></Greeter>
    </App>
 </div>
</body>


App.vue
<script>
import Greeter from "./components/Greeter.vue";
export default {
    components: { Greeter }
}
</script>
<template>
   <h1>Vue Application</h1>
   <Greeter></Greeter>
</template>

Greeter.vue
<script>
</script>
<template>
    <h1>Greeter</h1>
</template>

Welcome.vue
<script>
</script>
<template>
    <h1>Welcome</h1>
</template>

.................................................................................
			   Project layout

In general Projects can be categorized into  2 sections

1.feature based
products
customers
inventory
payment
etc...
2.framework based
src/
 components
    ....
Feature + framework
 
 components
    |
    features

components
  |
  products
    products-list.vue
    products-edit.vue
    products-search.vue

eg:

<!-- Component Using options api pattern -->
<script>
import Greeter from './components/greeter/Greeter.vue';
import Users from './components/users/Users.vue';
//java script code will go inside literal object,which must be exported using export default
export default {
    components: { Greeter, Users }
}
</script>
<template>
  <div>
     <Greeter></Greeter>
     <Users></Users>
  </div>
</template>
<style>
</style>

src/components/greeter/Greeter.vue

<script>
import Welcome from './Welcome.vue';
import Hello from './Hello.vue';
import Hai from './Hai.vue';

export default {
   components: { Welcome, Hello, Hai }
}
</script>
<template>
   <Welcome></Welcome>
   <Hello></Hello>
   <Hai></Hai>
</template>
<style>
</style>

src/components/users/User.vue
<script>

export default {
}
</script>
<template>
    <div>
        <h2>Users Page</h2>
    </div>
</template>
<style>
</style>



src/components/greeter/Welcome.vue
<script>
export default {

}
</script>
<template>
    <h1>Welcome to Vue!!!</h1>
</template>
<style>
</style>



src/components/greeter/Hello.vue
<script>
export default {

}
</script>
<template>
    <h1>Hello Vue!</h1>
</template>
<style>
</style>

src/components/greeter/Hai.vue
<script>
export default {
   
}
</script>
<template>
    <h1>Hai Vue</h1>
</template>
<style>
</style>
.....................................................................................
			   SFC - Composition API Pattern
.....................................................................................

In Compostion api pattern, there is a "hook(special function)" called "setup"

In Compostion api all javascript code will go inside "setup"  function only


				Compostion Api 
				     |
	--------------------------------------------------------------
        |                                                            |
     Imperative                                                 Declarative



Imperative:
 All code must go inside setup function

<script>
export default {

   setup(){
      //component code
   }

}
</script>

Declarative:

<script setup>
 //component
</script>

....

Component Composition using Composition Api pattern using Imperative style

<script>
import User from "./components/users/User.vue";

export default {
  components: {
    User
  },
  setup() {
    //javascript code
    return {   }
  }
}
</script>
<!-- <script setup>
import User from "./components/users/User.vue";
  //javascript code
</script> -->
<template>
  <h1>Vue App using Composition Api</h1>
  <User></User>
</template>
<style>
</style>
....................................................................................

eg:

src/components/App.vue

<!-- <script>
import User from "./components/users/User.vue";

export default {
  components: {
    User
  },
  setup() {
    //javascript code
    return {   }
  }
}
</script> -->
<script setup>
import User from "./components/users/User.vue";
  //javascript code
</script>
<template>
  <h1>Vue App using Composition Api</h1>
  <User></User>
</template>
<style>
</style>
...
src/components/Users.vue
<script setup>
</script>
<template>
    <h1>User Page</h1>
</template>
<style>
</style>
...................................................................................
				Task

Create Layout 
1.header
   |
   Logo
   SearchPanel
   LoginPanel
2.main
   |
   three sections
    -Vue features
3.Footer
   |
   Sponors
   copyright

You have to try

1.Options api
2.Compositions api with imperative and declarative Patterns
............................&&&&&&&&&&..............................................
			    Component Registeration
.....................................................................................

A Vue component needs to be "registered" so that Vue knows where to locate its implmeneation when it is encountered in a template.

Two Types of Registeration:

1.Global Registeration
  Global Components
2.Local Registeration
  Local Components

Global Components:
  Components are created and  registered as part of the application object
  Global Components can be accessed any where in the application without explicit   configuration

  import {createApp} from 'vue'

  const app=createApp(App)

  app.component()
  app.use()
  app.provide()

IN SFC with options object without global registeration
<script>
import ComponentA from './ComponentA.vue'
export default {
  components:ComponentA
}
<script>
<template>
   <ComponentA></ComponentA>
</template>



IN SFC with options object with global registeration
app.component('name',componentDefintion)

<script>
export default {

}
<script>
<template>
   <ComponentA></ComponentA>
</template>

IN SFC with composition api without global registration
<script setup>
import ComponentA from './ComponentA.vue'

<script>
<template>
   <ComponentA></ComponentA>
</template>


eg:
 app.component('name',componentDefintion)

interface App {
  component(name: string): Component | undefined
  component(name: string, component: Component): this
}

Global Components are registered in two mode

1.Using options object without build tools

import { createApp } from 'vue'

const app = createApp({})

app.component(
  // the registered name
  'MyComponent',
  // the implementation
  {
    /* ... */
  }
)
2.Using SFC  with build tool

import MyComponent from './App.vue'

app.component('MyComponent', MyComponent)

...................................................................................
		Global Component with Compostion(impeative) and Options api
...................................................................................

<!-- This synatx is common for both options api and composition api using imperative pattern -->
<script>
import Logo from './components/Logo.vue'
import StatusBar from './components/StatusBar.vue' //Global Component
export default {
  // components: { Logo } // Component Registration - Local compoent
}
</script>
<template>
   <Logo></Logo>
   <StatusBar></StatusBar>
</template>
<style>
</style>
................................................................................
			Global Component with Compostion(declarative)
...................................................................................

<script setup>
import Logo from './components/Logo.vue'
import StatusBar from './components/StatusBar.vue' //Global Component
</script>
<template>
    <Logo></Logo>
    <StatusBar></StatusBar>
</template>
<style>
</style>

.................................................................................
			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>
...................................................................................
			Global Vs Local Component Registration
.................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.
....................................................................................
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).

This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>
Vue supports both cases , but highly recommened is Pascal Case
.....................................................................................
			  Exploring Templates
.....................................................................................

Template is the representation of View
View is Runtime representation

Template can be static or dynamic 

Static templates are having pure html code
Dynamic templates are having html code + Vue instructions
Vue instructions are special symbols
  
Template  = html + data(state)

Data Binding:
.............
  Passing data from the Component to View and View to Component

Types of Data bidning:

1.interpolation
2.property /props binding
3.attribute binding
4.event binding
5.Two way data binding
6.class and style binding
...................................................................................
				Interpolation
....................................................................................

Transfering data(state) from Component to View.

State:
  State Can be represented in two ways
1.primitives - numbers,strings,boolean
  let name='subramanian'
  let salary=100
  let isValid=true
2.objects and collections -  literal object,arrays
  
  let profile = {
    id:1,
    name:'Arun'
  }
  let profiles = [{
    id:1,
    name:'Arun'
  },{
    id:2,
    name:'Bala'
  }]

SFC:
 1.Using Options api
 2.Using Composition api


Object literal syntax

let options = {
 
  data:?,
  props:?,
  methods:?

}

let user = { 
  id:1,
  name:'subu',
  isValid:true,
  skilss: ['javascript'],
  getAll: function(){
	///
  },
  save:function(user){
     //
  }
 
}
user.id,user.getAll()



es 5 way of writing functions

export default { 
  id:1,
  name:'subu',
  isValid:true,
  skilss: ['javascript'],
  getAll: function(){
	///
  },
  save:function(user){
     //
  }
 
}



es 6 way of writing functions

export default { 
  id:1,
  name:'subu',
  isValid:true,
  skilss: ['javascript'],
  //function es 6 synatx
  getAll(){
	///
  },
  save(user){
     //
  }
 
}
.............

data :
 A function which returns "reactive state" as object

<!-- options api pattern -->
<script>
export default {
    data() {
        //return state(data)
        return {
            message:'Hello'
        }
    }
}
</script>
<template>
</template>
<style>
</style>

How to bind data inside template which was returned from the "data" function.

{{variableName}} - interplation


Using Options Api:
<!-- options api pattern -->
<script>
export default {
    data() {
        //return state(data)
        return {
            message:'Hello'
        }
    }
}
</script>
<template>
<h1>{{message}}</h1>
</template>
<style>
</style>
<script>
import Greeter from './components/Greeter.vue';
export default {
    components: { Greeter }
}
</script>
<template>
    <Greeter></Greeter>
</template>
<style>
</style>



Using Composition Api:

<script> without setup attribute

<script setup> With setup attribute


<script> without setup attribute:
.................................

The component logic must be encapsulated inside a function called "setup"

export default {

 setup(){

   return {}
 }

}

eg:
<script>
//composition api with setup function
export default {
    setup() {
        console.log('setup is called')
        const message = 'Hello!!'
        //variables or any thing if you want to access inside template, must be returned via an object
        return {
            //message:message
            message
        }
    }
}
</script>
<template>
    <h1>Data Binding :Using Composition App with Setup Function</h1>
    <h1>{{ message }}</h1>
</template>

<script setup> With setup attribute:
.......................................
<script setup>
//variable declarations
const message = "Hello"
//function declarations
function sayHai() {
    return 'Hai'
}
</script>
<template>
    <h1>Data Binding :Using Composition App with Setup attribute</h1>
    <h1>{{ message }} {{ sayHai() }}</h1>
</template>

=><script setup> is compile time syntactic sugar for composition API inside SFCs
=>It is highly recommended syntax if you are using both SFCs and compostion API
=>It offers lot benefits over normal syntax

 1.More readable code with less boilerplate
 2.Better Runtime Performance
 3.Render performance
 4.Better IDE support

code segments inside script setup

1.variable declarations
2.function declarations
3.import other components and utiltity functions
....................................................................................
			 Data binding
....................................................................................

<script setup>
//declare state variables
const userId = 1
const firstName = 'Subramanian'
const salary = 10000
const status = true
const address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}
const skills = ['Javascript', 'Vue', 'Angular', 'React', 'Java']

</script>
<template>
    <div>
        <h1>User Details</h1>
        <h3>Id : {{ userId }}</h3>
        <h3>Name : {{ firstName }}</h3>
        <h3>Salary : {{ salary }}</h3>
        <h3>Address : {{ address.city }} {{ address.state }}</h3>
        <h3>Skills {{ skills }}</h3>

    </div>
</template>
<style>
</style>

App.vue
<script setup>
import User from './components/User.vue';
</script>
<template>
    <User></User>
</template>
<style>
</style>
.....................................................................................
				Directives
....................................................................................
What is directive?
  Directive is object which helps to create custom elements and attributes.
  Directive enchances existing html elements.

Vue is highly modular framework, code reuse is main objective.

Code Resue Patterns:

1.Compoents
2.Composables(Hooks)
3.Directives

Components are main building blocks,while composable are focused on "resuing stateful logic".
Custom Directives, on the other hand, are mainly intented for reusing logic that involes low-level DOM Acess on plain elements.

HTML element types:

1.built in elements and attributes
2.custom elements and attributes


<h1>Hello</h1> - built in element

HTML Compiler Work flow

<h1>Hello</h1> ------>compiler verfies this element is built in or not
		|
	   ---------------------
           |                   |
          yes                 no
      Browser parses the    Browser throws Exception called UnKnownElement and 			    convert that element as "text Node"
      element and render
      accordingly


<app-drawer> -  it is custom element, generally browser does not understand.

In 2007, W3C introduced new idea that developers can add their own tags/elements -
HTML 5
<app-drawer>
<app-logo>
We can teach browser via javascript.

<app-drawer> ------|js---rendering - Custom elements

Custom attributes:
  As part of HTML 5, We can introduce new attributes on existing html elements , we can attach js to teach browser how to interpt the attributes.

 <div id="" class="" style="" ></div>
       |       |       |
      attributes -  Built in attributes

  <div custom-attribute> </div>


Vue helps to add custom attributes on existing elements via "directives" -Attribute Directives

Directive is object, which encapsulate the logic of that attribute

Attribute directives syntax
.............................

v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak


<script setup>
const name = 'Subramanian'
</script>
<template>
    <div>
        <h1>Interpolation using mustace Notation</h1>
        <h1>Your Name : {{ name }}</h1>
        <h1>InterPolation using directive-innerText</h1>
        <!-- <h1 v-text="name"></h1> -->
        <h1 v-text="`Your Name is ${name}`"></h1>
        <h1>InterPolation using directive-innerHTML</h1>
        <h1 v-html="` Your Name is ${name}`"></h1>

    </div>
</template>
<style>
</style>
..................................................................................
			       v-bind
.................................................................................

v-bind binds html element attributes or component values(properties) dyamically.

Static binding
 <img src="logo.png"/>

dynamic binding
 if img location is given inside script as variable, now i want to bind that image to img element
<script>
  const imageUrl="logo.png"
</script>

<img v-bind:src="imageUrl"/>

<script setup>
const imageUrl = "/src/assets/logo.svg"
const isEnabled = true
</script>
<template>
    <h1>Bind Directives</h1>
    <div>
        <h2>Static Image</h2>
        <img src="./assets/logo.svg" height="100" width="100" />
    </div>
    <div>
        <h2>Dynamic Image using v-bind Directive</h2>
        <img v-bind:src="imageUrl" height="100" width="100" />
    </div>
    <div>
        <h2>Dynamic Image using v-bind Directive-short cut</h2>
        <img :src="imageUrl" height="100" width="100" />
    </div>
    <button :disabled="isEnabled">Show</button>
</template>
<style>
</style>
....................................................................................
			     Data  Representation in Vue
....................................................................................

Data can be reprsented inside component in two ways

1.state pattern
   The data is encasulated inside component itself
2.props pattern
   The data is supplied from outside(parent component)


State Pattern:

 Data is two type

data can be both primitive or objects(arrays)
 
1.Non Reactive 

2.Reactive 

Non Reactive data when you change /update, never tigger render cycles of view

eg:
<script>
export default {
    setup() {
        //state- non reactive
        const counter = 0
        return {
            counter
        }
    }
}
</script>
<template>
    <div>
        <h1>State Application -Non Reactive</h1>
        <h1>Counter : {{ counter }}</h1>
    </div>
</template>

if you want to change data, we need to interact with UI, we need event handling
.................................&&&&&&&&&&&&.......................................








				